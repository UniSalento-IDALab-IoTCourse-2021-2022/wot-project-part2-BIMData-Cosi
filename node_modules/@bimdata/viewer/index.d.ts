/* eslint-disable*/
declare module "@bimdata/viewer" {
  export default function makeBIMDataViewer(cfg: BDV.ViewerCfg): BDV.Viewer;
}

declare namespace BDV {
  interface Viewer {
    mount(
      containerElementOrSelector: HTMLElement | string,
      layout: Object
    ): Object;
    setLocale(lang: AvailableLangs): void;
    registerPlugin(plugin: PluginCfg, cfg?: Object): void;
    registerWindow(window: Object): void;
    unregisterWindow(windowName: string): void;
    setAccessToken(accessToken: string): void;
    loadIfcs(ifcIds: number[]): StateModel[];
  }

  enum AvailableLangs {
    "de",
    "en",
    "fr",
  }

  interface ViewerCfg {
    plugins: PluginsConfig;
    api: APIConfig;
    offlineOptions?: OfflineData;
    ui: UIConfig;
    logger?: { level: LogLevel };
    locale?: string;
  }

  interface PluginsConfig {
    split: boolean;
    header: boolean;
    "window-split": boolean;
    bcf:
      | boolean
      | {
          showAllAnnotations: boolean;
          headers: Object;
          apiUrl: string;
          fetchCurrentUser(): { id: string };
        };
    projection: boolean;
    section: boolean;
    fullscreen: boolean;
    search: boolean;
    windowSelector: boolean;
    viewer3d: {
      pivotMarker: boolean;
      navCube: boolean;
      edges: boolean;
    };
    "viewer2d-background": boolean;
    "structure-properties":
      | boolean
      | {
          merge: boolean;
          export: boolean;
          editProperties: boolean;
        };
    structure:
      | boolean
      | {
          merge: boolean;
          export: boolean;
        };
    properties:
      | boolean
      | {
          editProperties: boolean;
        };
    addPlugins: boolean;
  }

  interface OfflineOptions {
    allowUnmockedMethodsOnNetwork: boolean;
    data: OfflineData[];
  }

  interface OfflineData {
    id: number;
    name: string;
    status: string;
    structure_file: string;
    xkt_file: string;
    project_id: number;
    world_position: [number, number, number];
    errors: string[];
    warnings: string[];
    rawElements: Object;
    zones: Object;
  }

  interface APIConfig {
    ifcIds: number[];
    cloudId: number;
    projectId: number;
    accessToken: string;
    apiUrl?: string;
  }

  interface UIConfig {
    style: {
      /**
       * Css color
       */
      backgroundColor: string;
    };
    headerVisible: boolean;
    windowManager: boolean;
    version: boolean;
    bimdataLogo: boolean;
    contextMenu: {
      defaultCommands: boolean;
    };
  }

  enum LogLevel {
    "INFO",
    "WARNING",
    "ERROR",
  }

  type Events = {
    [eventName: string]: Object;
  };

  interface EventHandler<T extends Events> {
    on<N extends keyof T>(
      eventName: N,
      callback: (arg: T[N]) => void,
      options?: EventOptions
    ): number;
    once<N extends keyof T>(
      eventName: N,
      callback: (arg: T[N]) => void,
      options?: EventOptions
    ): number;
    off(subscriptionId: number): void;
    emit<N extends keyof T>(eventName: N, payload: T[N]): void;
    clear(): void;
  }

  interface EventOptions {
    getLastEvent?: boolean;
  }

  interface Api {
    apiUrl: string;
    cloudId: number;
    projectId: number;
    accessToken: string;
    apiClient: Object;
  }

  interface ModalManager {
    pushModal(component: Object, options?: { args: Object }): void;
    clearModal(): void;
  }

  interface ContextMenuCommand {
    label: string;
    picto: string;
    execute(): void;
    predicate?(): boolean;
  }

  interface ContextMenu {
    preventDefault(): void;
    registerContextCommand(command: ContextMenuCommand): boolean;
    registerCommand(command: ContextMenuCommand): boolean;
    unregisterCommand(command: ContextMenuCommand): boolean;
  }

  interface Shortcut {
    name: string;
    key: string;
    context: Object;
    execute(): void;
    ctrlKey: boolean;
    shiftKey: boolean;
    altKey: boolean;
  }

  interface ShortcutManager {
    getShortcut(name: string, context: Object): Object;
    registerShortcut(shortcut: Shortcut, context: Object): boolean;
    unregisterShortcut(shortcutName: string, context: Object): boolean;
  }

  type ContextEvents = {
    "3d-model-loaded": { ifc: StateModel; model: Object; plugin: Object };
    "3d-model-unloaded": { ifc: StateModel; plugin: Object };
    "2d-model-loaded": { ifc: StateModel; plugin: Object };
    "2d-model-unloaded": { ifc: StateModel; plugin: Object };
    "plugin-created": { pluginName: string; plugin: Plugin };
    "plugin-destroyed": { pluginName: string; plugin: Plugin };
    "plugin-menu-open": Plugin;
    "plugin-menu-close": Plugin;
  };

  type GlobalContextEvents = {
    "window-open": Window;
    "window-close": Window;
  };

  interface Context<T extends Events> {
    loading: boolean;
    incrementSpinnerProcesses: Function;
    decrementSpinnerProcesses: Function;
    registerShortcut: Function;
    unregisterShortcut(shortcutName: string): boolean;
    hub: EventHandler<T>;
    modals: ModalManager;
  }

  interface LocalContext extends Context<ContextEvents> {
    area: Object;
    getPlugin(pluginName: string): Plugin;
    pluginActivated: Function;
    pluginDeactivated: Function;
    el: Object;
    height: number;
    width: number;
    pluginsUnit: Object;
  }

  interface GlobalContext extends Context<ContextEvents & GlobalContextEvents> {
    areas: Object;
    mouseover: boolean;
    currentContext: Object;
    getPlugins(pluginName: string): Plugin[];
  }

  type StateEvents = {
    // models events
    "models-loaded": { models: StateModel[] };
    "models-unloaded": { models: StateModel[] };
    // ifcs events
    "ifcs-loaded": { ifcs: StateModel[] };
    "ifcs-unloaded": { ifcs: StateModel[] };
    // objects events
    "objects-added": { objects: StateObject[] };
    "objects-removed": { objects: StateObject[] };
    "objects-selected": { objects: StateObject[]; options?: Object };
    "objects-deselected": { objects: StateObject[]; options?: Object };
    "objects-highlighted": { objects: StateObject[]; options?: Object };
    "objects-unhighlighted": { objects: StateObject[]; options?: Object };
    "objects-shown": { objects: StateObject[]; options?: Object };
    "objects-hidden": { objects: StateObject[]; options?: Object };
    "objects-xrayed": { objects: StateObject[]; options?: Object };
    "objects-unxrayed": { objects: StateObject[]; options?: Object };
    "objects-colorized": {
      objects: StateObject[];
      color: number;
      options?: Object;
    };
  };

  interface State {
    hub: EventHandler<StateEvents>;
    uuidsMap: { get(uuid: string): StateObject[] };

    /**** getters ****/
    getObjectsByUuids(uuids: string[]): StateObject[];
    getObject(id: number): StateObject;
    getModel(id: number): StateModel;
    getIfc(id: number): StateModel;
    selectedObjects: StateObject[];
    colorizedObjects: StateObject[];
    deselectedObjects: StateObject[];
    highlightedObjects: StateObject[];
    unhighlightedObjects: StateObject[];
    visibleObjects: StateObject[];
    unvisibleObjects: StateObject[];
    xrayedObjects: StateObject[];
    unxrayedObjects: StateObject[];

    /**** models ****/
    models: StateModel[];
    modelsMap: Map<number, StateModel>;
    loadModels(modelIds: string[]): Promise<StateModel[]>;
    unloadModels(modelIds: string[]);
    /**** ifcs ****/
    ifcs: StateModel[];
    ifcsMap: Map<number, StateModel>;
    loadIfcs(ifcIds: string[]): Promise<StateModel[]>;
    unloadIfcs(ifcIds: string[]);

    /**** objects ****/
    objects: StateObject[];
    objectsMap: Map<number, StateObject>;
    selectObjects(ids: number[]): void;
    colorizeObjects(ids: number[], color?: string): void;
    deselectObjects(ids: number[]): void;
    highlightObjects(ids: number[]): void;
    unhighlightObjects(ids: number[]): void;
    showObjects(ids: number[]): void;
    hideObjects(ids: number[]): void;
    xrayObjects(ids: number[]): void;
    unxrayObjects(ids: number[]): void;
    isolateObjects(ids: number[]): void;
    reintegrateObjects(): void;
  }

  interface APIObject {
    children: APIObject[];
    model: StateModel;
    ifc: StateModel;
    longname: string;
    name: string;
    object_type: string;
    parent: StateObject;
    type: string;
    uuid: string;
  }

  interface StateModel {
    id: number;
    type: ModelType;
    status: ModelStatus;
    structure: Object;
    objects: StateObject[];
    uuids: Map<string, StateObject>;
  }

  enum ModelType {
    IFC = "IFC",
    DWG = "DWG",
    DXF = "DXF",
    GLTF = "GLTF",
    PDF = "PDF",
    JPEG = "JPEG",
    PNG = "PNG",
    OBJ = "OBJ",
    DAE = "DAE",
    BFX = "BFX",
    METABUILDING = "METABUILDING",
  }

  interface StateObject extends APIObject {
    id: number;
    model: StateModel;
    ifc: StateModel;
    visible: boolean;
    pickable: boolean;
    selected: boolean;
    highlighted: boolean;
    xrayed: boolean;
    color: string;
    // advanced getters
    descendants;
    ancestors: StateObject[];
    getFirstAncestorWithType(type: string): StateObject;
    storey: StateObject;
    space: StateObject;
  }

  type ModelStatus = "C" | "E" | "P" | "I";

  interface VueInstance {
    $t(message: string): string;
  }

  interface $viewer {
    vm: VueInstance;
    pluginManager: Object;
    commandManager: Object;
    shortcutManager: ShortcutManager;
    contextMenu: ContextMenu;
    logger: Object;
    i18n: Object;
    api: Api;
    localContext: LocalContext;
    globalContext: GlobalContext;
    state: State;
  }

  interface Window {
    flyingHeader: boolean;
    icon: Object;
    label: string;
    name: string;
    plugins: string[];
  }

  interface PluginCfg {
    name: string;
    component?: Object;
    button?: Object;
    addToWindows?: string[];
    startupScript?: ($viewer: $viewer) => void;
  }

  type Plugin<T> = VueComponent<{ $viewer: $viewer } | T>;

  type VueComponent<T> =
    | {
        methods: T;
        computed: T;
      }
    | T;

  type Viewer3dPlugin = Plugin<{
    fitViewObjects(uuids: string[]): void;
    getCameraPosition(): Object;
    getProjection(): string;
    getViewpoint(snapshot?: boolean): Object;
    setCameraPosition(cameraPosition?: Object): void;
  }>;
}
